// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

#pragma once

#include "core/graph/contrib_ops/onnx_function_util.h"
#include "orttraining/core/graph/graph_augmenter.h"
#include "core/graph/graph_utils.h"
#include "core/graph/model.h"

namespace onnxruntime {
namespace training {

/**
 * @brief Pattern graph input data types.
 * Class representing allowed data types for inputs of the pattern graph.
 */
struct PGraphInputTypes {
  friend class PGraphInput;

 public:
  /**
    @brief Predefined categories for common used data type set.
  */
  enum class TypesCategory {
    AllIntegerTensorTypes,
    AllFloatTensorTypes,
    AllIntegerAndFloatTensorTypes,
  };

 public:
  /* Construct allowed data types from predefined categories. */
  PGraphInputTypes(TypesCategory category);
  /* Construct allowed data types from explicit list of data types. */
  PGraphInputTypes(const std::vector<ONNX_NAMESPACE::TensorProto_DataType>& allowed_types)
      : allowed_types_(allowed_types) {}

  /**
   * We need a valid data type for the input when building the pattern graph.
   * Here we choose the first data type in the allowed list. For user of this class,
   * default type is meaningless, and will not be used as strict type checking,
   * instead, if target input/output arg's data type in allowed_types_, then it is a match.
   */
  ONNX_NAMESPACE::TensorProto_DataType GetDefaultType() const {
    ORT_ENFORCE(allowed_types_.size(), "Empty type list in PGraphInputTypes.");
    return allowed_types_.at(0);
  }

 private:
  void Init(const std::vector<ONNX_NAMESPACE::TensorProto_DataType>& types) {
    allowed_types_ = types;
  }

  std::vector<ONNX_NAMESPACE::TensorProto_DataType> allowed_types_;
};

/**
 * @brief Pattern graph input data shapes.
 * Currently majorly maintain a list of ranks.
 */
struct PGraphInputShapes {
  friend class PGraphInput;

 public:
  PGraphInputShapes(const std::vector<int>& allowed_ranks)
      : allowed_ranks_(allowed_ranks) {
  }

  bool CanBeAnyRank() const {
    return allowed_ranks_.empty();
  }

 private:
  std::vector<int> allowed_ranks_;
};

/**
 * @brief Pattern graph input description.
 * Class representing a graph input to a pattern graph.
 *
 * During node matching, by default, all user given fields will be checked, compared with
 * the target graph.
 */
struct PGraphInput {
  friend class PatternGraph;

 public:
  PGraphInput(const std::string& node_arg_name,
              const PGraphInputTypes& type)
      : node_arg_name_(node_arg_name),
        allowed_data_types_(type.allowed_types_) {
    allowed_ranks_ = {};
  }

  PGraphInput(const std::string& node_arg_name,
              const PGraphInputTypes& type,
              const PGraphInputShapes& shape)
      : node_arg_name_(node_arg_name),
        allowed_data_types_(type.allowed_types_),
        allowed_ranks_(shape.allowed_ranks_) {}

  bool MatchesDataType(const Graph& graph, const NodeArg& input_arg) const;
  bool MatchesShape(const Graph& graph, const NodeArg& input_arg) const;

  std::string GetArgName() const {
    return node_arg_name_;
  }

 private:
  std::string node_arg_name_;

  std::vector<ONNX_NAMESPACE::TensorProto_DataType> allowed_data_types_;
  std::vector<int> allowed_ranks_;
};

/**
 * @brief Pattern graph node description.
 * Class representing a graph node to a pattern graph.
 *
 * During node matching, by default, all user given fields will be checked, compared with
 * the target node.
 */
struct PGraphNode {
  friend class DefaultNodeCompareFunc;
  friend class PatternGraph;

 public:
  /**
   * Create a node using mostly string-based description, among them:
   * @param op_type ONNX operator name.
   * @param input_args_names input arg names (generated by either PGraphInput or other PGraphNode as output_arg_name),
   *    which this operator takes as inputs.
   * @param output_args_names output arg names, which this operator generates as outputs.
   * @param node_name [optional] a unique string (in the same pattern graph) representing name of the node.
   *    If not specified, will automatically assigned.
   * @param domain_version_maps [optional] a list of allowed opset domains/versions.
   *    If not specified, node compare will ignore domain/version check.
   * @param attributes [optional] attributes that will be used to compare during node compare.
   * @param output_edges_count [optional] the output edge out that will be used in node compare.
   *    if it remains default, it will decide the output_edges_count by the generated onnx graph.
   *    If it is set to negative, then no check for output edges count will be taken in the node.
   *    If it is set to positive, then we will check the corresponding node in target graph that if it has that number output edges.
   *    (todo): we need consider the output edge count constraint on each output of the node. Now we
   *        only compare the total edge count.
   */
  PGraphNode(const std::string& op_type,
             const std::vector<std::string>& input_args_names,
             const std::vector<std::string>& output_args_names,
             const std::string& node_name = "",
             const std::unordered_map<std::string, std::vector<int>>& domain_version_maps = {},
             const std::vector<AttributeProto>& attributes = {},
             int output_edges_count = 0,
             bool ignore_input_arg_orders = false)
      : op_type_(op_type),
        input_args_names_(input_args_names),
        output_args_names_(output_args_names),
        node_name_(node_name),
        output_edges_count_(output_edges_count),
        domain_version_maps_(domain_version_maps),
        attributes(attributes),
        ignore_order_(ignore_input_arg_orders) {
    if (node_name.empty()) {
      CreateNodeName();
    }
  }

  const std::string& GetOpType() const {
    return op_type_;
  }

  const std::string& GetNodeName() const {
    return node_name_;
  }

  bool NameEquals(const std::string& name) const {
    return node_name_.compare(name) == 0;
  }

  bool MatchesOpType(const std::string& op_type) const {
    return op_type_.compare(op_type) == 0;
  }

  bool MatchesDomainVersion(const std::string& domain, const int version) const;

  bool IgnoreNodeArgOrder() const {
    return ignore_order_;
  }

  const std::unordered_map<std::string, std::vector<int>>& GetDomainVersionMap() const { return domain_version_maps_; }

 private:
  void CreateNodeName();

  std::string op_type_;
  std::vector<std::string> input_args_names_;
  std::vector<std::string> output_args_names_;
  std::string node_name_;
  int output_edges_count_;
  std::unordered_map<std::string, std::vector<int>> domain_version_maps_;
  std::vector<AttributeProto> attributes;
  bool ignore_order_;
};

}  // namespace training
}  // namespace onnxruntime
